// ✅ FILE: lib/auth.ts
import { getServerSession } from "next-auth";
import { authOptions } from "@/pages/api/auth/[...nextauth]";

export const getUserFromSession = async (req: any, res: any) => {
  const session = await getServerSession(req, res, authOptions);
  if (!session) return null;
  return session.user;
};


// ✅ FILE: components/CapsuleGallery.tsx
"use client";

import { useQuery } from "@tanstack/react-query";
import { useWallet } from "@/hooks/useWallet";

export default function CapsuleGallery() {
  const { address } = useWallet();

  const { data, isLoading, error } = useQuery({
    queryKey: ["capsules", address],
    queryFn: async () => {
      const res = await fetch(`/api/capsule/list?owner=${address}`);
      if (!res.ok) throw new Error("Failed to fetch capsules");
      return res.json();
    },
    enabled: !!address,
  });

  if (isLoading) return <div>Loading capsules...</div>;
  if (error) return <div>Error loading capsules</div>;

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
      {data?.map((capsule) => (
        <div key={capsule.id} className="p-4 border rounded shadow bg-white">
          <h3 className="text-lg font-semibold">{capsule.title}</h3>
          <p className="text-sm text-gray-500">{capsule.description}</p>
          {capsule.file_path && (
            <video src={capsule.file_path} controls className="w-full mt-2 rounded" />
          )}
          <p className="text-xs text-gray-400 mt-1">Created: {new Date(capsule.created_at).toLocaleString()}</p>
        </div>
      ))}
    </div>
  );
}


// ✅ FILE: pages/api/capsule/list.ts
import { NextApiRequest, NextApiResponse } from "next";
import { createClient } from "@supabase/supabase-js";

const supabase = createClient(process.env.SUPABASE_URL, process.env.SUPABASE_ANON_KEY);

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const { owner } = req.query;
  if (!owner) return res.status(400).json({ error: "Missing owner" });

  const { data, error } = await supabase.from("capsules").select("*").eq("owner", owner);
  if (error) return res.status(500).json({ error });
  res.status(200).json(data);
}


// ✅ FILE: utils/pinToIPFS.ts
import { Web3Storage, File } from "web3.storage";

export async function pinToIPFS({ file, name }) {
  const client = new Web3Storage({ token: process.env.NEXT_PUBLIC_WEB3STORAGE_KEY });
  const cid = await client.put([new File([file], name)]);
  return `https://ipfs.io/ipfs/${cid}`;
}


// ✅ FILE: utils/mintNFT.ts
import { writeContract } from "@wagmi/core";
import { parseAbi } from "viem";

const nftAddress = "0xYourNFTCapsuleAddress";
const nftABI = parseAbi([
  "function mint(address to, string memory uri) public returns (uint256)"
]);

export async function mintCapsuleNFT(to: string, ipfsUrl: string) {
  return await writeContract({
    address: nftAddress,
    abi: nftABI,
    functionName: "mint",
    args: [to, ipfsUrl],
  });
}


// ✅ FILE: pages/api/capsule/mint.ts (updated)
import { NextApiRequest, NextApiResponse } from "next";
import { createClient } from "@supabase/supabase-js";
import { pinToIPFS } from "@/utils/pinToIPFS";

const supabase = createClient(process.env.SUPABASE_URL, process.env.SUPABASE_ANON_KEY);

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== "POST") return res.status(405).end();

  const { title, description, filePath, owner, veritas } = req.body;
  if (!title || !filePath || !owner) return res.status(400).json({ error: "Missing fields" });

  // 1. Pin metadata to IPFS
  const ipfsMeta = JSON.stringify({ title, description, file: filePath });
  const ipfsUrl = await pinToIPFS({ file: new Blob([ipfsMeta], { type: "application/json" }), name: `${title}.json` });

  // 2. Save to Supabase
  const { data, error } = await supabase.from("capsules").insert({
    title,
    description,
    file_path: filePath,
    owner,
    veritas,
    ipfs_url: ipfsUrl,
    created_at: new Date().toISOString(),
  });

  if (error) return res.status(500).json({ error });

  // 3. Optionally mint NFT
  // await mintCapsuleNFT(owner, ipfsUrl); // Uncomment after full test

  return res.status(200).json({ success: true });
}
