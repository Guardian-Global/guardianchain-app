üîê 1. contracts/VeritasCapsuleNFT.sol (Final)
üìÑ Create: contracts/VeritasCapsuleNFT.sol

solidity
Copy
Edit
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";

contract VeritasCapsuleNFT is ERC721URIStorageUpgradeable, OwnableUpgradeable, UUPSUpgradeable {
    uint256 public nextTokenId;
    mapping(uint256 => bool) public isSoulbound;
    mapping(uint256 => uint256) public griefScore;
    mapping(uint256 => string) public vaultScoreLabel;
    mapping(uint256 => string) public verifierSignature;

    event VeritasSealed(
        address indexed minter,
        uint256 indexed tokenId,
        bool soulbound,
        uint256 grief,
        string vault,
        string sig
    );

    function initialize() public initializer {
        __ERC721_init("VeritasCapsuleNFT", "VCNFT");
        __Ownable_init();
        __UUPSUpgradeable_init();
        nextTokenId = 1;
    }

    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}

    function mintVeritasCapsule(
        address to,
        string memory tokenUri,
        bool soulbound,
        uint256 grief,
        string memory vault,
        string memory sig
    ) public onlyOwner returns (uint256) {
        uint256 tokenId = nextTokenId++;
        _safeMint(to, tokenId);
        _setTokenURI(tokenId, tokenUri);
        isSoulbound[tokenId] = soulbound;
        griefScore[tokenId] = grief;
        vaultScoreLabel[tokenId] = vault;
        verifierSignature[tokenId] = sig;

        emit VeritasSealed(to, tokenId, soulbound, grief, vault, sig);
        return tokenId;
    }

    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal override {
        require(!isSoulbound[tokenId] || from == address(0), "Soulbound: cannot transfer");
        super._beforeTokenTransfer(from, to, tokenId);
    }
}
‚úÖ Use OpenZeppelin upgrades plugin to deploy this contract:

bash
Copy
Edit
npm install @openzeppelin/contracts-upgradeable @openzeppelin/hardhat-upgrades
üîÅ Next Drop:
SealModal.tsx (frontend)

VeritasSealAPI.ts (API handler for DocuSign + IPFS)

mint-nft.tsx (UI for minting sealed capsule NFTs)

‚úÖ Let me know when this contract is pasted into contracts/VeritasCapsuleNFT.sol ‚Äî then I‚Äôll immediately drop the backend + UI.